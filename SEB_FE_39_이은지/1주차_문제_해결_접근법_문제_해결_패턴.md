# 문제 해결 접근법

## 1. 문제의 이해(Understand the Problem)

- 문제를 **나만의 방식대로 다시 생각**할 수 있나요?
- 문제가 어떤 **입력값**을 담고 있나요?
- 문제를 해결책에서 어떤 **출력값**이 나와야 하나요?
- 입력값이 출력값을 결정할 수 있나요? (문제 해결을 위한 충분한 정보를 가지고 있나요?)
- 문제에서 중요한 부분을 어떻게 라벨을 지정할 수 있나요? (무엇이 중요한가요?)

## 2. 구체적 예제들(Explore Concrete Examples)

- 입력값과 출력값을 간단한 예제로 시작할 것
- 간단한 예제에서 점점 더 복잡한 예제로 진행할 것
- **빈 입력값**을 고려할 것(유효하지 않은 입력을 해결하는 방법을 배울 수 있습니다.)
-

## 3. 세분화(Break It Down)

- 문제 해결을 위한 단계들을 명확하게 작성해 볼 것
- 의사코드를 아주 세세하게 작성할 필요는 없습니다.
- 해결 방법을 세분화하는 것은 면접에서도 큰 도움이 됩니다.
- 해결 단계를 작성하면 접근 방법을 알고 있다는 것을 면접관에게 보여줄 수 있습니다.
- 즉 시간이 부족해 전부 구현하지 못하더라도 기본적인 해결 능력을 갖추고 있다는 것을 보여줄 수 있습니다.

## 4. 해결 또는 단순화(Solve/Simplify)

- 어려운 부분을 무시하고 단순한 해결책을 먼저 작성할 것
- 그다음에 다시 어려운 부분으로 돌아가 통합시킬 컷

## 5. 되돌아보기와 리팩터(Look Back and Refactor)

- 결과를 확인할 수 있나요?
- 결과를 **다른 방식**으로 도출할 수 있나요?
- 해결책을 한 눈에 이해할 수 있나요?
- 결과나 방법을 **다른 문제에도 적용**할 수 있을까요?
- 해결책의 **성능을 향상**시킬 수 있나요?
- 다른 사람들은 이 문제를 어떻게 해결했나요?

# 문제 해결 패턴

## 1. 빈도수 세기 패턴(Frequency Counter)

- 값이 다른 값에 포함되는지 여부를 비교할 때, 데이터를 입력값이나 두 개 이상의 빈도 혹은 특정하게 발생하는 빈도와 비교할 때 유리한 패턴입니다.

- 값을 비교할 때 중첩 루프 또는 시간복잡도가 O(n^2)인 방법을 피할 수 있습니다.

### 예시 문제

> 배열 2개를 입력받아 첫 번째 배열의 요소들을 제곱한 값을 두 번째 배열에 모두 포함되어 있는지 판단해 true 또는 false를 반환하는 same 함수를 작성하라. (값의 순서는 상관없음.)

### 😡 중첩 루프를 사용한 naive solution

```js
function same(arr1, arr2) {
  if (arr1.length !== arr2.length) return false;

  for (let i = 0; i < arr1.length; i++) {
    let correctIndex = arr2.indexOf(arr1[i] ** 2);
    if (correctIndex === -1) return false;
    arr2.splice(correctIndex, 1);
  }

  return true;
}
```

- 시간복잡도: 반복문인 for문 안에 배열 요소를 검색하는 indexOf()문이 들어있습니다.
- 중첩되어 반복하기 때문에 시간복잡도는 O(n^2)입니다.

### 😊 빈도수 세기 패턴을 사용한 solution

- 두 객체를 생성해서 각 배열의 개별 값의 빈도를 세어줍니다.

```js
function same(arr1, arr2) {
  if (arr1.length !== arr2.length) return false;

  let frequencyCounter1 = {};
  let frequencyCounter2 = {};

  for (let val of arr1) {
    frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1;
  }
  for (let val of arr2) {
    frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1;
  }

  for (let key in frequencyCounter1) {
    if (!(key ** 2 in frequencyCounter2)) return false;
    if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) return false;
  }
  return true;
}
```

- 시간복잡도: 반복문인 for문이 3개 존재합니다. -> O(3n)
- 빅오표기법에서 계수는 무시할 수 있으므로 결과적으로 시간복잡도는 O(n)입니다.
